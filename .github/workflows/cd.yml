name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main]
  
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      version:
        description: 'Version to deploy'
        required: true
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    environment:
      name: staging
      url: https://staging.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Deploy to staging
      run: |
        # Update image tags in k8s manifests
        sed -i "s|secure-api-frontend:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}|g" k8s/frontend.yml
        sed -i "s|secure-api-backend:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}|g" k8s/backend.yml
        
        # Apply configurations
        kubectl apply -f k8s/namespace.yml
        kubectl apply -f k8s/configmap.yml
        kubectl apply -f k8s/secret.yml
        kubectl apply -f k8s/mysql.yml
        kubectl apply -f k8s/redis.yml
        kubectl apply -f k8s/backend.yml
        kubectl apply -f k8s/frontend.yml
        kubectl apply -f k8s/monitoring.yml
        kubectl apply -f k8s/ingress.yml

    - name: Wait for deployment
      run: |
        kubectl rollout status deployment/backend -n secure-api-system --timeout=600s
        kubectl rollout status deployment/frontend -n secure-api-system --timeout=600s

    - name: Run smoke tests
      run: |
        # Wait for services to be ready
        sleep 30
        
        # Test backend health
        kubectl run test-backend --rm -i --restart=Never --image=curlimages/curl -- \
          curl -f http://backend-service.secure-api-system.svc.cluster.local:8080/actuator/health
        
        # Test frontend
        kubectl run test-frontend --rm -i --restart=Never --image=curlimages/curl -- \
          curl -f http://frontend-service.secure-api-system.svc.cluster.local:80/health

    - name: Notify staging deployment
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: 'üöÄ Successfully deployed to staging environment'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Production Deployment Approval
  production-approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment:
      name: production-approval
    
    steps:
    - name: Request production deployment approval
      run: echo "Requesting approval for production deployment"

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: production-approval
    environment:
      name: production
      url: https://api.example.com
    
    strategy:
      type: blue-green
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Create backup
      run: |
        # Backup current deployment
        kubectl get deployment backend -n secure-api-system -o yaml > backup-backend-$(date +%Y%m%d-%H%M%S).yaml
        kubectl get deployment frontend -n secure-api-system -o yaml > backup-frontend-$(date +%Y%m%d-%H%M%S).yaml

    - name: Blue-Green Deployment
      run: |
        # Create green environment
        sed -i 's/name: backend/name: backend-green/g' k8s/backend.yml
        sed -i 's/name: frontend/name: frontend-green/g' k8s/frontend.yml
        sed -i "s|secure-api-frontend:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}|g" k8s/frontend.yml
        sed -i "s|secure-api-backend:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}|g" k8s/backend.yml
        
        # Deploy green environment
        kubectl apply -f k8s/backend.yml
        kubectl apply -f k8s/frontend.yml
        
        # Wait for green deployment
        kubectl rollout status deployment/backend-green -n secure-api-system --timeout=600s
        kubectl rollout status deployment/frontend-green -n secure-api-system --timeout=600s

    - name: Run production smoke tests
      run: |
        # Test green environment
        kubectl run test-backend-green --rm -i --restart=Never --image=curlimages/curl -- \
          curl -f http://backend-green-service.secure-api-system.svc.cluster.local:8080/actuator/health
        
        kubectl run test-frontend-green --rm -i --restart=Never --image=curlimages/curl -- \
          curl -f http://frontend-green-service.secure-api-system.svc.cluster.local:80/health

    - name: Switch traffic to green
      run: |
        # Update service selectors to point to green deployment
        kubectl patch service backend-service -n secure-api-system -p '{"spec":{"selector":{"version":"green"}}}'
        kubectl patch service frontend-service -n secure-api-system -p '{"spec":{"selector":{"version":"green"}}}'

    - name: Monitor deployment
      run: |
        # Monitor for 5 minutes
        sleep 300
        
        # Check if deployment is stable
        kubectl get pods -n secure-api-system -l version=green
        
        # Check error rates (this would typically integrate with monitoring)
        echo "Monitoring deployment stability..."

    - name: Cleanup old deployment
      run: |
        # Remove blue deployment after successful green deployment
        kubectl delete deployment backend -n secure-api-system --ignore-not-found=true
        kubectl delete deployment frontend -n secure-api-system --ignore-not-found=true
        
        # Rename green to blue for next deployment
        kubectl patch deployment backend-green -n secure-api-system -p '{"metadata":{"name":"backend"}}'
        kubectl patch deployment frontend-green -n secure-api-system -p '{"metadata":{"name":"frontend"}}'

    - name: Update monitoring dashboards
      run: |
        # Update Grafana dashboards with new deployment info
        echo "Updating monitoring dashboards..."

    - name: Notify production deployment
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: 'üéâ Successfully deployed to production environment'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Rollback on Failure
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure()
    needs: [deploy-staging, deploy-production]
    
    steps:
    - name: Rollback staging
      if: needs.deploy-staging.result == 'failure'
      run: |
        kubectl rollout undo deployment/backend -n secure-api-system
        kubectl rollout undo deployment/frontend -n secure-api-system

    - name: Rollback production
      if: needs.deploy-production.result == 'failure'
      run: |
        # Restore from backup
        kubectl apply -f backup-backend-*.yaml
        kubectl apply -f backup-frontend-*.yaml
        
        # Switch traffic back to blue
        kubectl patch service backend-service -n secure-api-system -p '{"spec":{"selector":{"version":"blue"}}}'
        kubectl patch service frontend-service -n secure-api-system -p '{"spec":{"selector":{"version":"blue"}}}'

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        text: '‚ö†Ô∏è Deployment failed, rollback initiated'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Post-deployment tests
  post-deployment-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: deploy-production
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run integration tests
      run: |
        # Run comprehensive integration tests against production
        echo "Running post-deployment integration tests..."

    - name: Run performance tests
      run: |
        # Run performance tests to ensure no regression
        echo "Running performance regression tests..."

    - name: Update deployment status
      run: |
        # Update deployment tracking system
        echo "Deployment completed successfully at $(date)"